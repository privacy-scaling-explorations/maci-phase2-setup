diff --git a/dist/index.mjs b/dist/index.mjs
index 7a43b4de11f0d142bd774a77fe2de4374b7a11e7..63340eb77e76349d6ad2797107c82d9fe13aa853 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -19,8 +19,8 @@ import { utils } from 'ffjavascript';
 import winston from 'winston';
 import { initializeApp } from 'firebase/app';
 import { signInWithCredential, initializeAuth, getAuth } from 'firebase/auth';
-import { ContractFactory } from 'ethers';
-import solc from 'solc';
+// import { ContractFactory } from 'ethers';
+// import solc from 'solc';
 
 // Main part for the Hermez Phase 1 Trusted Setup URLs to download PoT files.
 const potFileDownloadMainUrl = `https://hermez.s3-eu-west-1.amazonaws.com/`;
@@ -1554,49 +1554,49 @@ const verifyGROTH16ProofOnChain = async (contract, proof) => {
     const res = await contract.verifyProof(proof.arg1, proof.arg2, proof.arg3, proof.arg4);
     return res;
 };
-/**
- * Compiles a contract given a path
- * @param contractPath <string> path to the verifier contract
- * @returns <Promise<any>> the compiled contract
- */
-const compileContract = async (contractPath) => {
-    if (!fs.existsSync(contractPath))
-        throw new Error("The contract path does not exist. Please make sure that you are passing a valid path to the contract and try again.");
-    const data = fs.readFileSync(contractPath).toString();
-    const input = {
-        language: "Solidity",
-        sources: {
-            Verifier: { content: data }
-        },
-        settings: {
-            outputSelection: {
-                "*": {
-                    "*": ["*"]
-                }
-            }
-        }
-    };
-    try {
-        const compiled = JSON.parse(solc.compile(JSON.stringify(input), { import: { contents: "" } }));
-        return compiled.contracts.Verifier.Verifier;
-    }
-    catch (error) {
-        throw new Error("There was an error while compiling the smart contract. Please check that the file is not corrupted and try again.");
-    }
-};
-/**
- * Deploy the verifier contract
- * @param contractFactory <ContractFactory> The contract factory
- * @returns <Promise<Contract>> The contract instance
- */
-const deployVerifierContract = async (contractPath, signer) => {
-    const compiledContract = await compileContract(contractPath);
-    // connect to hardhat node running locally
-    const contractFactory = new ContractFactory(compiledContract.abi, compiledContract.evm.bytecode.object, signer);
-    const contract = await contractFactory.deploy();
-    await contract.deployed();
-    return contract;
-};
+// /**
+//  * Compiles a contract given a path
+//  * @param contractPath <string> path to the verifier contract
+//  * @returns <Promise<any>> the compiled contract
+//  */
+// const compileContract = async (contractPath) => {
+//     if (!fs.existsSync(contractPath))
+//         throw new Error("The contract path does not exist. Please make sure that you are passing a valid path to the contract and try again.");
+//     const data = fs.readFileSync(contractPath).toString();
+//     const input = {
+//         language: "Solidity",
+//         sources: {
+//             Verifier: { content: data }
+//         },
+//         settings: {
+//             outputSelection: {
+//                 "*": {
+//                     "*": ["*"]
+//                 }
+//             }
+//         }
+//     };
+//     try {
+//         const compiled = JSON.parse(solc.compile(JSON.stringify(input), { import: { contents: "" } }));
+//         return compiled.contracts.Verifier.Verifier;
+//     }
+//     catch (error) {
+//         throw new Error("There was an error while compiling the smart contract. Please check that the file is not corrupted and try again.");
+//     }
+// };
+// /**
+//  * Deploy the verifier contract
+//  * @param contractFactory <ContractFactory> The contract factory
+//  * @returns <Promise<Contract>> The contract instance
+//  */
+// const deployVerifierContract = async (contractPath, signer) => {
+//     const compiledContract = await compileContract(contractPath);
+//     // connect to hardhat node running locally
+//     const contractFactory = new ContractFactory(compiledContract.abi, compiledContract.evm.bytecode.object, signer);
+//     const contract = await contractFactory.deploy();
+//     await contract.deployed();
+//     return contract;
+// };
 /**
  * Verify a ceremony validity
  * 1. Download all artifacts
@@ -1667,11 +1667,11 @@ const verifyCeremony = async (functions, firestore, ceremonyPrefix, outputDirect
         if (!isProofValid)
             throw new Error(`Could not verify the proof for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
         // 8. deploy Verifier contract and verify the proof on-chain
-        const verifierContract = await deployVerifierContract(verifierLocalPath, signer);
-        const formattedProof = await formatSolidityCalldata(publicSignals, proof);
-        const isProofValidOnChain = await verifyGROTH16ProofOnChain(verifierContract, formattedProof);
-        if (!isProofValidOnChain)
-            throw new Error(`Could not verify the proof on-chain for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
+        // const verifierContract = await deployVerifierContract(verifierLocalPath, signer);
+        // const formattedProof = await formatSolidityCalldata(publicSignals, proof);
+        // const isProofValidOnChain = await verifyGROTH16ProofOnChain(verifierContract, formattedProof);
+        // if (!isProofValidOnChain)
+        //     throw new Error(`Could not verify the proof on-chain for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
     }
 };
 
@@ -1861,4 +1861,4 @@ var TestingEnvironment;
     TestingEnvironment["PRODUCTION"] = "PRODUCTION";
 })(TestingEnvironment || (TestingEnvironment = {}));
 
-export { CeremonyState, CeremonyTimeoutType, CeremonyType, ParticipantContributionStep, ParticipantStatus, RequestType, TestingEnvironment, TimeoutType, autoGenerateEntropy, blake512FromPath, checkAndPrepareCoordinatorForFinalization, checkIfObjectExist, checkParticipantForCeremony, commonTerms, compareCeremonyArtifacts, compareHashes, compileContract, completeMultiPartUpload, computeSHA256ToHex, computeSmallestPowersOfTauForCircuit, convertBytesOrKbToGb, createCustomLoggerForFile, createS3Bucket, downloadAllCeremonyArtifacts, downloadCeremonyArtifact, exportVerifierAndVKey, exportVerifierContract, exportVkey, extractPoTFromFilename, extractPrefix, extractR1CSInfoValueForGivenKey, finalContributionIndex, finalizeCeremony, finalizeCircuit, formatSolidityCalldata, formatZkeyIndex, fromQueryToFirebaseDocumentInfo, generateGROTH16Proof, generateGetObjectPreSignedUrl, generatePreSignedUrlsParts, generateValidContributionsAttestation, generateZkeyFromScratch, genesisZkeyIndex, getAllCollectionDocs, getBucketName, getCeremonyCircuits, getCircuitBySequencePosition, getCircuitContributionsFromContributor, getCircuitsCollectionPath, getClosedCeremonies, getContributionsCollectionPath, getContributionsValidityForContributor, getCurrentActiveParticipantTimeout, getCurrentFirebaseAuthUser, getDocumentById, getOpenedCeremonies, getParticipantsCollectionPath, getPotStorageFilePath, getPublicAttestationPreambleForContributor, getR1CSInfo, getR1csStorageFilePath, getTimeoutsCollectionPath, getTranscriptStorageFilePath, getVerificationKeyStorageFilePath, getVerifierContractStorageFilePath, getWasmStorageFilePath, getZkeyStorageFilePath, githubReputation, initializeFirebaseCoreServices, isCoordinator, multiPartUpload, numExpIterations, p256, permanentlyStoreCurrentContributionTimeAndHash, potFileDownloadMainUrl, potFilenameTemplate, progressToNextCircuitForContribution, progressToNextContributionStep, queryCollection, resumeContributionAfterTimeoutExpiration, setupCeremony, signInToFirebaseWithCredentials, solidityVersion, temporaryStoreCurrentContributionMultiPartUploadId, temporaryStoreCurrentContributionUploadedChunkData, toHex, verificationKeyAcronym, verifierSmartContractAcronym, verifyCeremony, verifyContribution, verifyGROTH16Proof, verifyGROTH16ProofOnChain, verifyZKey };
+export { CeremonyState, CeremonyTimeoutType, CeremonyType, ParticipantContributionStep, ParticipantStatus, RequestType, TestingEnvironment, TimeoutType, autoGenerateEntropy, blake512FromPath, checkAndPrepareCoordinatorForFinalization, checkIfObjectExist, checkParticipantForCeremony, commonTerms, compareCeremonyArtifacts, compareHashes, completeMultiPartUpload, computeSHA256ToHex, computeSmallestPowersOfTauForCircuit, convertBytesOrKbToGb, createCustomLoggerForFile, createS3Bucket, downloadAllCeremonyArtifacts, downloadCeremonyArtifact, exportVerifierAndVKey, exportVerifierContract, exportVkey, extractPoTFromFilename, extractPrefix, extractR1CSInfoValueForGivenKey, finalContributionIndex, finalizeCeremony, finalizeCircuit, formatSolidityCalldata, formatZkeyIndex, fromQueryToFirebaseDocumentInfo, generateGROTH16Proof, generateGetObjectPreSignedUrl, generatePreSignedUrlsParts, generateValidContributionsAttestation, generateZkeyFromScratch, genesisZkeyIndex, getAllCollectionDocs, getBucketName, getCeremonyCircuits, getCircuitBySequencePosition, getCircuitContributionsFromContributor, getCircuitsCollectionPath, getClosedCeremonies, getContributionsCollectionPath, getContributionsValidityForContributor, getCurrentActiveParticipantTimeout, getCurrentFirebaseAuthUser, getDocumentById, getOpenedCeremonies, getParticipantsCollectionPath, getPotStorageFilePath, getPublicAttestationPreambleForContributor, getR1CSInfo, getR1csStorageFilePath, getTimeoutsCollectionPath, getTranscriptStorageFilePath, getVerificationKeyStorageFilePath, getVerifierContractStorageFilePath, getWasmStorageFilePath, getZkeyStorageFilePath, githubReputation, initializeFirebaseCoreServices, isCoordinator, multiPartUpload, numExpIterations, p256, permanentlyStoreCurrentContributionTimeAndHash, potFileDownloadMainUrl, potFilenameTemplate, progressToNextCircuitForContribution, progressToNextContributionStep, queryCollection, resumeContributionAfterTimeoutExpiration, setupCeremony, signInToFirebaseWithCredentials, solidityVersion, temporaryStoreCurrentContributionMultiPartUploadId, temporaryStoreCurrentContributionUploadedChunkData, toHex, verificationKeyAcronym, verifierSmartContractAcronym, verifyCeremony, verifyContribution, verifyGROTH16Proof, verifyGROTH16ProofOnChain, verifyZKey };
diff --git a/dist/index.node.js b/dist/index.node.js
index 34d20d952f5950ca9e0ea1b180c12c5db80db5b7..af79eae38367a5d3e36f6d75051bb44ada4f9fa0 100644
--- a/dist/index.node.js
+++ b/dist/index.node.js
@@ -22,7 +22,7 @@ var winston = require('winston');
 var app = require('firebase/app');
 var auth = require('firebase/auth');
 var ethers = require('ethers');
-var solc = require('solc');
+// var solc = require('solc');
 
 // Main part for the Hermez Phase 1 Trusted Setup URLs to download PoT files.
 const potFileDownloadMainUrl = `https://hermez.s3-eu-west-1.amazonaws.com/`;
@@ -1556,49 +1556,49 @@ const verifyGROTH16ProofOnChain = async (contract, proof) => {
     const res = await contract.verifyProof(proof.arg1, proof.arg2, proof.arg3, proof.arg4);
     return res;
 };
-/**
- * Compiles a contract given a path
- * @param contractPath <string> path to the verifier contract
- * @returns <Promise<any>> the compiled contract
- */
-const compileContract = async (contractPath) => {
-    if (!fs.existsSync(contractPath))
-        throw new Error("The contract path does not exist. Please make sure that you are passing a valid path to the contract and try again.");
-    const data = fs.readFileSync(contractPath).toString();
-    const input = {
-        language: "Solidity",
-        sources: {
-            Verifier: { content: data }
-        },
-        settings: {
-            outputSelection: {
-                "*": {
-                    "*": ["*"]
-                }
-            }
-        }
-    };
-    try {
-        const compiled = JSON.parse(solc.compile(JSON.stringify(input), { import: { contents: "" } }));
-        return compiled.contracts.Verifier.Verifier;
-    }
-    catch (error) {
-        throw new Error("There was an error while compiling the smart contract. Please check that the file is not corrupted and try again.");
-    }
-};
-/**
- * Deploy the verifier contract
- * @param contractFactory <ContractFactory> The contract factory
- * @returns <Promise<Contract>> The contract instance
- */
-const deployVerifierContract = async (contractPath, signer) => {
-    const compiledContract = await compileContract(contractPath);
-    // connect to hardhat node running locally
-    const contractFactory = new ethers.ContractFactory(compiledContract.abi, compiledContract.evm.bytecode.object, signer);
-    const contract = await contractFactory.deploy();
-    await contract.deployed();
-    return contract;
-};
+// /**
+//  * Compiles a contract given a path
+//  * @param contractPath <string> path to the verifier contract
+//  * @returns <Promise<any>> the compiled contract
+//  */
+// const compileContract = async (contractPath) => {
+//     if (!fs.existsSync(contractPath))
+//         throw new Error("The contract path does not exist. Please make sure that you are passing a valid path to the contract and try again.");
+//     const data = fs.readFileSync(contractPath).toString();
+//     const input = {
+//         language: "Solidity",
+//         sources: {
+//             Verifier: { content: data }
+//         },
+//         settings: {
+//             outputSelection: {
+//                 "*": {
+//                     "*": ["*"]
+//                 }
+//             }
+//         }
+//     };
+//     try {
+//         const compiled = JSON.parse(solc.compile(JSON.stringify(input), { import: { contents: "" } }));
+//         return compiled.contracts.Verifier.Verifier;
+//     }
+//     catch (error) {
+//         throw new Error("There was an error while compiling the smart contract. Please check that the file is not corrupted and try again.");
+//     }
+// };
+// /**
+//  * Deploy the verifier contract
+//  * @param contractFactory <ContractFactory> The contract factory
+//  * @returns <Promise<Contract>> The contract instance
+//  */
+// const deployVerifierContract = async (contractPath, signer) => {
+//     const compiledContract = await compileContract(contractPath);
+//     // connect to hardhat node running locally
+//     const contractFactory = new ethers.ContractFactory(compiledContract.abi, compiledContract.evm.bytecode.object, signer);
+//     const contract = await contractFactory.deploy();
+//     await contract.deployed();
+//     return contract;
+// };
 /**
  * Verify a ceremony validity
  * 1. Download all artifacts
@@ -1669,11 +1669,11 @@ const verifyCeremony = async (functions, firestore$1, ceremonyPrefix, outputDire
         if (!isProofValid)
             throw new Error(`Could not verify the proof for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
         // 8. deploy Verifier contract and verify the proof on-chain
-        const verifierContract = await deployVerifierContract(verifierLocalPath, signer);
-        const formattedProof = await formatSolidityCalldata(publicSignals, proof);
-        const isProofValidOnChain = await verifyGROTH16ProofOnChain(verifierContract, formattedProof);
-        if (!isProofValidOnChain)
-            throw new Error(`Could not verify the proof on-chain for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
+        // const verifierContract = await deployVerifierContract(verifierLocalPath, signer);
+        // const formattedProof = await formatSolidityCalldata(publicSignals, proof);
+        // const isProofValidOnChain = await verifyGROTH16ProofOnChain(verifierContract, formattedProof);
+        // if (!isProofValidOnChain)
+        //     throw new Error(`Could not verify the proof on-chain for Circuit ${ceremonyArtifact.circuitPrefix}. Please check that the artifacts are correct as well as the inputs to the circuit, and try again.`);
     }
 };
 
@@ -1871,7 +1871,7 @@ exports.checkParticipantForCeremony = checkParticipantForCeremony;
 exports.commonTerms = commonTerms;
 exports.compareCeremonyArtifacts = compareCeremonyArtifacts;
 exports.compareHashes = compareHashes;
-exports.compileContract = compileContract;
+// exports.compileContract = compileContract;
 exports.completeMultiPartUpload = completeMultiPartUpload;
 exports.computeSHA256ToHex = computeSHA256ToHex;
 exports.computeSmallestPowersOfTauForCircuit = computeSmallestPowersOfTauForCircuit;
